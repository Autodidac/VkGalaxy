#version 430

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062

//----------------------------------------------------------------------------//

struct Particle
{
	vec2 pos;
	float height;
	float angle;
	float tiltAngle;
	float angleVel;
	float opacity;
};

//----------------------------------------------------------------------------//

layout(std140, binding = 0) buffer Particles
{
	Particle particles[];
};

//----------------------------------------------------------------------------//

float u_bulgeRad = 1250.0;

float u_baseHeight = 300.0;
float u_angleOffset = 2.0 * PI;
float u_eccentricity = 0.85;

float u_maxRad = 3500.0;

//----------------------------------------------------------------------------//

float _SEED = 0.0;

float rand()
{
    return fract(sin(_SEED++) * 43758.5453);
}

void srand(float seed)
{
	_SEED = seed;
}

//----------------------------------------------------------------------------//

float rand_radius()
{
	float r = rand();
	r = pow(2.0, 10.0 * r - 10.0); //basic quadratic easing

	return r * u_maxRad;
}

//----------------------------------------------------------------------------//

void main()
{
	srand(gl_GlobalInvocationID.x / 1024.0); //particles spawn on top of each other unless i divide by a constant

	float rad = rand_radius();
	float angle = rand() * 2.0 * PI;
	float tiltAngle = (rad / u_maxRad) * u_angleOffset;
	float angleVel = -10.0 * sqrt(1.0 / rad);

	float height;
	if(rad < u_bulgeRad)
		height = u_baseHeight + (50.0 + 100.0 * cos(PI * rad / u_bulgeRad)) * (rand() * 2.0 - 1.0);
	else
		height = u_baseHeight + 50.0 * (rand() * 2.0 - 1.0);

	Particle particle;
	particle.pos = vec2(rad, u_eccentricity * rad);
	particle.height = height;
	particle.angle = angle;
	particle.tiltAngle = tiltAngle;
	particle.angleVel = angleVel;
	particle.opacity = 0.1 + rand() * 0.4;

	particles[gl_GlobalInvocationID.x] = particle;
}